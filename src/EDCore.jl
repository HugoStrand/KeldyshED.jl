using KeldyshED.Operators
using KeldyshED.Hilbert
using LinearAlgebra
using SparseArrays

export EDCore
export fock_states, energies, unitary_matrices
export c_connection, cdag_connection, c_matrix, cdag_matrix
export partition_function, density_matrix

"""Eigensystem within one invariant subspace of the Hamiltonian"""
struct EigenSystem{ScalarType <: Number}
  # Eigenvalues, in ascending order
  # The energy reference point is shifted so that the global energy minimum is zero
  eigenvalues::Vector{Float64}
  # Unitary transformation matrix \hat U from the Fock basis to the eigenbasis.
  # Defined so that \hat H = \hat U \mathrm{diag}(E) * \hat U^\dagger.
  unitary_matrix::Matrix{ScalarType}
end

"""Lightweight exact diagonalization solver"""
struct EDCore{ScalarType <: Number}
  # Full Hilbert space of the problem
  full_hs::FullHilbertSpace
  # Invariant subspaces
  subspaces::Vector{HilbertSubspace}
  # Eigensystems in all subspaces
  eigensystems::Vector{EigenSystem}
  # Connections between subspaces generated by C†
  # creation_connection[cdag_linear_index][sp] -> sp'
  creation_connection::Vector{Dict{Int,Int}}
  # Connections between subspaces generated by C
  # creation_connection[c_linear_index][sp] -> sp'
  annihilation_connection::Vector{Dict{Int,Int}}
  # cdag_matrices[cdag_linear_index][sp] = matrix from subspace sp to subspace sp'
  cdag_matrices::Vector{Dict{Int,Matrix{ScalarType}}}
  # c_matrices[c_linear_index][sp] = matrix from subspace sp to subspace sp'
  c_matrices::Vector{Dict{Int,Matrix{ScalarType}}}
  # Energy of the ground state (before shift)
  gs_energy::Float64
end

"""
  Reduce a given Hamiltonian to a block-diagonal form and diagonalize it

  This constructor calls the auto-partition procedure, and the QR algorithm
  to diagonalize the blocks. The invariant subspaces of the Hamiltonian are
  chosen such that all creation and annihilation operators from the provided
  fundamental operator set map one subspace to one subspace.
"""
function EDCore(hamiltonian::OperatorExpr{S}, soi::SetOfIndices) where {S <: Number}
  full_hs = FullHilbertSpace(soi)

  h = Operator{FullHilbertSpace, S}(hamiltonian, soi)
  SP = SpacePartition{FullHilbertSpace, S}(full_hs, h, false)

  # Merge subspaces
  Cd_elements = Vector{SparseMatrixCSC{S, Int}}(undef, length(soi))
  C_elements = Vector{SparseMatrixCSC{S, Int}}(undef, length(soi))
  for (indices, n) in soi
    op_c_dag = Operator{FullHilbertSpace, S}(c_dag(Tuple(indices)...), soi)
    op_c = Operator{FullHilbertSpace, S}(c(Tuple(indices)...), soi)

    Cd_elements[n], C_elements[n] = merge_subspaces!(SP, op_c_dag, op_c, true)
  end

  # Fill subspaces
  subspaces = [HilbertSubspace() for sp=1:numsubspaces(SP)]
  for (n, fs) in pairs(full_hs)
    insert!(subspaces[SP[n]], fs)
  end

  # Fill connections
  creation_connection = [Dict{Int,Int}() for n=1:length(soi)]
  annihilation_connection = [Dict{Int,Int}() for n=1:length(soi)]
  for (indices, n) in soi
    rows = rowvals(Cd_elements[n])
    for f = 1:length(full_hs)
      for i in nzrange(Cd_elements[n], f)
        creation_connection[n][SP[rows[i]]] = SP[f]
      end
    end
    rows = rowvals(C_elements[n])
    for f = 1:length(full_hs)
      for i in nzrange(C_elements[n], f)
        annihilation_connection[n][SP[rows[i]]] = SP[f]
      end
    end
  end

  # Compute energy levels and eigenvectors of the Hamiltonian
  eigensystems = Vector{EigenSystem}(undef, length(subspaces))
  gs_energy::Float64 = Inf

  for (spn, subspace) in enumerate(subspaces)
    h_matrix = Matrix{S}(undef, length(subspace), length(subspace))
    i_state = StateVector{HilbertSubspace, S}(subspace)
    dim = length(subspace)
    for i=1:dim
      i_state[i] = one(S)
      f_state = h * i_state
      h_matrix[:, i] = f_state.amplitudes
      i_state[i] = zero(S)
    end

    eig = eigen(S <: Complex ? Hermitian(h_matrix) : Symmetric(h_matrix), 1:dim)
    eigensystems[spn] = EigenSystem(eig.values, eig.vectors)
    gs_energy = min(gs_energy, eigensystems[spn].eigenvalues[1])
  end

  # Shift energy reference point
  for es in eigensystems; es.eigenvalues .-= gs_energy end

  # Reorder eigensystems and subspaces along their minimal energy
  eigensystem_lt = (es1::EigenSystem, es2::EigenSystem) ->
    es1.eigenvalues[1] < es2.eigenvalues[1]
  perm = sortperm(eigensystems; lt = eigensystem_lt)
  inv_perm = invperm(perm)

  permute!(eigensystems, perm)
  permute!(subspaces, perm)

  # Update connections
  for (indices, n) in soi
    creation_connection[n] =
      Dict{Int,Int}(inv_perm[i] => inv_perm[f] for (i, f) in creation_connection[n])
    annihilation_connection[n] =
      Dict{Int,Int}(inv_perm[i] => inv_perm[f] for (i, f) in annihilation_connection[n])
  end

  # Fill cdag_matrices and c_matrices
  make_c_matrix = (connections, op_expr) -> begin
    op = Operator{FullHilbertSpace, S}(op_expr, soi)

    result = Dict{Int,Matrix{S}}()
    for (from_spn, to_spn) in connections
      from_sp = subspaces[from_spn]
      to_sp = subspaces[to_spn]

      mat = zeros(S, length(to_sp), length(from_sp))

      from_s = StateDict{FullHilbertSpace, S}(full_hs)
      for i=1:length(from_sp)
        full_hs_i = getstateindex(full_hs, from_sp[i])
        from_s[full_hs_i] = one(S)
        to_s = op * from_s
        proj_s = project(to_s, to_sp)
        for (j, a) in pairs(proj_s); mat[j, i] = a end
        from_s[full_hs_i] = zero(S)
      end

      result[from_spn] = (eigensystems[to_spn].unitary_matrix)' * mat *
                          eigensystems[from_spn].unitary_matrix
    end
    result
  end

  cdag_matrices = [Dict{Int,Matrix{S}}() for n=1:length(soi)]
  c_matrices = [Dict{Int,Matrix{S}}() for n=1:length(soi)]
  for (indices, n) in soi
    cdag_matrices[n] = make_c_matrix(creation_connection[n], c_dag(Tuple(indices)...))
    c_matrices[n] = make_c_matrix(annihilation_connection[n], c(Tuple(indices)...))
  end

  EDCore{S}(full_hs,
            subspaces,
            eigensystems,
            creation_connection,
            annihilation_connection,
            cdag_matrices,
            c_matrices,
            gs_energy)
end

function Base.show(io::IO, ed::EDCore)
  println(io, "Dimension of full Hilbert space: ", length(ed.full_hs))
  println(io, "Number of invariant subspaces: ", length(ed.subspaces))
  for (n, sp) in enumerate(ed.subspaces)
    println(io, "  Subspace $n, dim = $(length(sp))")
    println(io, "    Basis Fock states: $(sp.fock_states)")
    println(io, "    Energy levels: $(ed.eigensystems[n].eigenvalues)")
  end
  println(io, "Ground state energy: ", length(ed.gs_energy))
end

"""Subspace-to-subspace connection generated by operator C"""
function c_connection(ed::EDCore, op_linear_index::Int, sp_index::Int)
  get(ed.annihilation_connection[op_linear_index], sp_index, nothing)
end

"""Subspace-to-subspace connection generated by operator C†"""
function cdag_connection(ed::EDCore, op_linear_index::Int, sp_index::Int)
  get(ed.creation_connection[op_linear_index], sp_index, nothing)
end

"""Matrix block of fundamental operator C"""
function c_matrix(ed::EDCore, op_linear_index::Int, sp_index::Int)
  ed.c_matrices[op_linear_index][sp_index]
end

"""Matrix block of fundamental operator C†"""
function cdag_matrix(ed::EDCore, op_linear_index::Int, sp_index::Int)
  ed.cdag_matrices[op_linear_index][sp_index]
end

"""List of Fock states for each subspace"""
fock_states(ed::EDCore) = [sp.fock_states for sp in ed.subspaces]

"""List of energy levels for each subspace"""
energies(ed::EDCore) = [es.eigenvalues for es in ed.eigensystems]

"""List of unitary matrices for each subspace"""
unitary_matrices(ed::EDCore) = [es.unitary_matrix for es in ed.eigensystems]

"""Partition function"""
function partition_function(ed::EDCore, beta)
  sum(sum(exp.(-beta * es.eigenvalues)) for es in ed.eigensystems)
end

"""Equilibrium density matrix in the block-diagonal form"""
function density_matrix(ed::EDCore, beta)
  z = partition_function(ed, beta)
  [Diagonal(exp.(-beta * es.eigenvalues) / z) for es in ed.eigensystems]
end

