module Hilbert

using DataStructures
using KeldyshED.Operators

export SetOfIndices, reversemap
export FockState, HilbertSpace, HilbertSubspace, getstateindex

################
# SetOfIndices #
################

"""Mapping from Operators.IndicesType to a linear index"""
mutable struct SetOfIndices
  map_index_n::SortedDict{IndicesType, Int}
end

SetOfIndices() = SetOfIndices(SortedDict{IndicesType, Int}())
function SetOfIndices(v::Vector{IndicesType})
  SetOfIndices(SortedDict{IndicesType, Int}(i => n for (n, i) in enumerate(v)))
end

"""Insert a new index sequence"""
function Base.insert!(soi::SetOfIndices, indices::IndicesType)
  insert!(soi.map_index_n, indices, length(soi.map_index_n) + 1)
  # Reorder the linear indices
  soi.map_index_n = SortedDict{IndicesType, Int}(
    k => n for (n, (k, v)) in enumerate(soi.map_index_n)
  )
end

"""Insert a new index sequence"""
function Base.insert!(soi::SetOfIndices, indices...)
  insert!(soi, IndicesType([indices...]))
end

function Base.:(==)(soi1::SetOfIndices, soi2::SetOfIndices)
  soi1.map_index_n == soi2.map_index_n
end

Base.getindex(soi::SetOfIndices, indices) = soi.map_index_n[indices]
function Base.getindex(soi::SetOfIndices, indices...)
  soi.map_index_n[IndicesType([indices...])]
end

Base.in(indices, soi::SetOfIndices) = indices in keys(soi.map_index_n)

"""Build and return the reverse map: Int -> IndicesType"""
reversemap(soi::SetOfIndices) = collect(keys(soi.map_index_n))

#####################################
# SetOfIndices: Iteration interface #
#####################################
Base.eltype(soi::SetOfIndices) = Pair{IndicesType, Int}

Base.length(soi::SetOfIndices) = length(soi.map_index_n)
Base.isempty(soi::SetOfIndices) = isempty(soi.map_index_n)

function Base.size(soi::SetOfIndices, dim = 1)
  @assert dim == 1
  length(soi)
end

Base.iterate(soi::SetOfIndices) = iterate(soi.map_index_n)
Base.iterate(soi::SetOfIndices, it) = iterate(soi.map_index_n, it)

Base.keys(soi::SetOfIndices) = keys(soi.map_index_n)
Base.values(soi::SetOfIndices) = values(soi.map_index_n)
Base.pairs(soi::SetOfIndices) = pairs(soi.map_index_n)

################
# HilbertSpace #
################

const FockState = UInt64

"""
  A Hilbert space spanned by all fermionic Fock states generated by a given set
  of creation/annihilation operators.
"""
struct HilbertSpace
  dim::UInt64
end

HilbertSpace() = HilbertSpace(0)
"""Hilbert space generated by creation/annihilation operators with given indices"""
HilbertSpace(soi::SetOfIndices) = HilbertSpace(1 << length(soi))

Base.:(==)(hs1::HilbertSpace, hs2::HilbertSpace) = hs1.dim == hs2.dim

Base.in(fs::FockState, hs::HilbertSpace) = fs < hs.dim

function Base.getindex(hs::HilbertSpace, index)
  if index <= hs.dim
    FockState(index - 1)
  else
    throw(BoundsError(x, "Fock state does not exist (index too big)"))
  end
end

"""Return Fock state generated by a product of creation operators with given indices"""
function Base.getindex(hs::HilbertSpace, soi_indices::Pair{SetOfIndices,Set{IndicesType}})
  foldl((fs, ind) -> fs + (FockState(1) << (soi_indices[1][ind] - 1)),
        soi_indices[2];
        init = FockState(0))
end

"""Find the index of a given Fock state within hs"""
function getstateindex(hs::HilbertSpace, fs::FockState)
  if fs < hs.dim
    Int(fs + 1)
  else
    throw(BoundsError(x, "Fock state is not part of this Hilbert space"))
  end
end

#####################################
# HilbertSpace: Iteration interface #
#####################################
Base.eltype(hs::HilbertSpace) = FockState

Base.length(hs::HilbertSpace) = convert(Integer, hs.dim)
Base.isempty(hs::HilbertSpace) = hs.dim == 0

function Base.size(hs::HilbertSpace, dim = 1)
  @assert dim == 1
  length(hs)
end

function Base.iterate(hs::HilbertSpace)
  hs.dim > 0 ? (FockState(0), 0) : nothing
end
function Base.iterate(hs::HilbertSpace, it)
  it < hs.dim - 1 ? (FockState(it + 1), it + 1) : nothing
end

Base.keys(hs::HilbertSpace) = LinearIndices(1:hs.dim)
Base.values(hs::HilbertSpace) = [FockState(i) for i=0:hs.dim-1]
function Base.pairs(hs::HilbertSpace)
  Iterators.Pairs([FockState(i) for i=0:hs.dim-1], LinearIndices(1:hs.dim))
end

###################
# HilbertSubspace #
###################

"""Hilbert subspace, as an ordered set of basis Fock states."""
struct HilbertSubspace
  # Index of this subspace, as a part of a full Hilbert space
  id::Int
  # List of all Fock states
  fock_states::Vector{FockState}
  # Reverse map to quickly find the index of a state
  fock_to_index::Dict{FockState,Int}
end

function HilbertSubspace(id::Int)
  HilbertSubspace(id, Vector{FockState}(), Dict{FockState,Int}())
end
HilbertSubspace() = HilbertSubspace(0)

function Base.insert!(hss::HilbertSubspace, fs::FockState)
  push!(hss.fock_states, fs)
  hss.fock_to_index[fs] = length(hss.fock_states)
end

"""
  Two subspaces are considered equal iff they have the same id and
  equal sets of basis Fock states.
"""
function Base.:(==)(hss1::HilbertSubspace, hss2::HilbertSubspace)
  hss1.id == hss2.id && hss1.fock_states == hss2.fock_states
end

Base.in(fs::FockState, hss::HilbertSubspace) = fs in hss.fock_states

Base.getindex(hss::HilbertSubspace, index) = getindex(hss.fock_states, index)

"""Find the index of a given Fock state within hss"""
getstateindex(hss::HilbertSubspace, fs::FockState) = hss.fock_to_index[fs]

########################################
# HilbertSubspace: Iteration interface #
########################################
Base.eltype(hss::HilbertSubspace) = FockState

Base.length(hss::HilbertSubspace) = length(hss.fock_states)
Base.isempty(hss::HilbertSubspace) = isempty(hss.fock_states)

function Base.size(hss::HilbertSubspace, dim = 1)
  @assert dim == 1
  length(hss)
end

Base.iterate(hss::HilbertSubspace) = iterate(hss.fock_states)
Base.iterate(hss::HilbertSubspace, it) = iterate(hss.fock_states, it)

Base.keys(hss::HilbertSubspace) = keys(hss.fock_states)
Base.values(hss::HilbertSubspace) = values(hss.fock_states)
Base.pairs(hss::HilbertSubspace) = pairs(hss.fock_states)

end # module Hilbert
